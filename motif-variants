#!/usr/bin/env python

from __future__ import print_function

from argparse import ArgumentParser
import sys

from Bio import SeqIO
import pysam

# Testing for now
max_motif_size = 6
motif_list = ['CTCCAG', 'CTGGAG']

def main(infile, outfile, reference):
    '''
    Identify variants that cause the gain or loss of motifs.
    '''

    vcf_file = read_input(infile)
    sequence = str(SeqIO.read(reference,"fasta").seq)
    variant_neighborhoods = gerrymander(vcf_file, max_motif_size)

    motif_counts = {motif:{} for motif in motif_list}

    for neighborhood in variant_neighborhoods:
        for motif in motif_list:
            variant_position = neighborhood[0].pos
            reference_motifs = motifs(
                reference_segment(neighborhood,sequence,max_motif_size),
                motif)
            variant_motifs = motifs(
                variant_segment(neighborhood,sequence,max_motif_size),
                motif)
            if not (reference_motifs == 0 and variant_motifs == 0):
                motif_counts[motif][variant_position] = (reference_motifs,
                                                         variant_motifs)
    print_motif_summary(motif_counts)

def read_input(infile):
    if infile.endswith('.vcf.gz'):
        mode = 'rb'
    elif infile.endswith('.vcf'):
        mode = 'r'
    else:
        print("Input file must be VCF or compressed VCF",file=sys.stderr)
        sys.exit(1)
    return pysam.VariantFile(infile, mode)

def gerrymander(vcf_file, radius):
    '''
    Return variants positioned within a certain range of each other
    '''
    districts = []
    distance = 0
    last_position = 0
    block = []

    for record in vcf_file:
        distance = record.pos - last_position

        if distance > radius:
            # The current block is complete; start a new one
            districts.append(block)
            block = []
        else:
            # reset the range check
            distance = 0

        block.append(record)
        last_position = record.pos

    # The last block didn't get added yet
    districts.append(block)
    # The first block is always empty
    return districts[1:]

def reference_segment(neighborhood, sequence, radius):
    # 1 must be subtracted from the VCF positions because VCF positions
    # are one-based and Python's string indexing is zero-based.
    return sequence[neighborhood[0].pos-1-radius:neighborhood[-1].pos-1+radius]

def variant_segment(neighborhood, sequence, radius):
    '''
    Apply variants to get the consensus sequence for the given segment
    '''
    segment = reference_segment(neighborhood, sequence, radius)
    start_offset = neighborhood[0].pos - radius

    for variant in neighborhood:
        local_position = variant.pos - start_offset
        seq_prefix = segment[:local_position]
        seq_suffix = segment[local_position:].replace(
            variant.ref,variant.alts[0],1)
        variant_segment = seq_prefix + seq_suffix

    return variant_segment

def motifs(sequence, motif):
    positions = 0
    offset = 0
    while True:
        try:
            next_instance = sequence.index(motif, offset)
            # The previous command will throw an exception
            # if there is no next instance.
            positions += 1
            offset = next_instance + 1
        except ValueError:
            break
    return positions

def print_motif_summary(motif_counts):
    for motif in motif_counts.iterkeys():
        print(motif)
        print("\t".join(
            ['position','reference','variant']
        ))
        for position in iter(sorted(motif_counts[motif].iterkeys())):
            print("\t".join(
                [str(position),
                 str(motif_counts[motif][position][0]),
                 str(motif_counts[motif][position][1])]
            ))

if __name__ == '__main__':
    parser = ArgumentParser(description='Detect motif gain and loss')
    parser.add_argument('infile',
                        default='-')
    parser.add_argument('-o','--outfile',
                        default='-')
    parser.add_argument('--reference',
                        required=True)
    arguments = parser.parse_args()
    main(infile=arguments.infile,
         outfile=arguments.outfile,
         reference=arguments.reference)
