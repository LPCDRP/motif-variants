#!/usr/bin/env python

from __future__ import print_function

from argparse import ArgumentParser
import sys

from Bio import SeqIO
import pysam

# Testing for now
max_motif_size = 6
motif_list = ['CTCCAG', 'CTGGAG']

def main(infile, outfile, reference):
    '''
    Identify variants that cause the gain or loss of motifs.
    '''

    vcf_file = read_input(infile)
    sequence = str(SeqIO.read(reference,"fasta").seq)
    variant_neighborhoods = gerrymander(vcf_file, max_motif_size)

    positions = dict()

    for neighborhood in variant_neighborhoods:
        for motif in motif_list:
            positions[motif] = dict()
            positions[motif]['reference'] = motifs(
                reference_segment(neighborhood,sequence),
                motif)
            positions[motif]['variant'] = motifs(
                variant_segment(neighborhood,sequence),
                motif)

    print_motif_summary(positions)

def read_input(infile):
    if infile.endswith('.vcf.gz'):
        mode = 'rb'
    elif infile.endswith('.vcf'):
        mode = 'r'
    else:
        print("Input file must be VCF or compressed VCF",file=sys.stderr)
        sys.exit(1)
    return pysam.VariantFile(infile, mode)

def gerrymander(vcf_file, radius):
    '''
    Return variants positioned within a certain range of each other
    '''
    districts = []
    distance = 0
    last_position = 0
    block = []

    for record in vcf_file:
        distance = record.pos - last_position

        if distance > radius:
            # The current block is complete; start a new one
            districts.append(block)
            block = []
        else:
            # reset the range check
            distance = 0

        block.append(record)
        last_position = record.pos

    # The last block didn't get added yet
    districts.append(block)
    # The first block is always empty
    return districts[1:]

def reference_segment(neighborhood, sequence):
    # 1 must be subtracted from the VCF positions because VCF positions
    # are one-based and Python's string indexing is zero-based.
    return sequence[neighborhood[0].pos-1:neighborhood[-1].pos-1]

def variant_segment(neighborhood, sequence):
    '''
    Apply variants to get the consensus sequence for the given segment
    '''
    segment = reference_segment(neighborhood, sequence)
    start_offset = neighborhood[0].pos

    for variant in neighborhood:
        local_position = variant.pos - start_offset
        seq_prefix = segment[:local_position]
        seq_suffix = segment[local_position:].replace(
            variant.ref,variant.alts[0],1)
        variant_segment = seq_prefix + seq_suffix

    return variant_segment

def motifs(sequence, motif):
    positions = []
    offset = 0
    while True:
        try:
            next_instance = sequence.index(motif, offset)
            positions.append(next_instance)
            offset = next_instance + 1
        except ValueError:
            break
    return positions

def print_motif_summary(positions):
    for motif in positions.iterkeys():
        print(motif)
        print("\t".join(
            ['reference']+positions[motif]['reference']
        ))
        print("\t".join(
            ['variant']+positions[motif]['variant']
        ))

if __name__ == '__main__':
    parser = ArgumentParser(description='Detect motif gain and loss')
    parser.add_argument('infile',
                        default='-')
    parser.add_argument('-o','--outfile',
                        default='-')
    parser.add_argument('--reference',
                        required=True)
    arguments = parser.parse_args()
    main(infile=arguments.infile,
         outfile=arguments.outfile,
         reference=arguments.reference)
